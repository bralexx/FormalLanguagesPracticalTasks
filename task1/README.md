# Алгоритм
Вместо регулярок храним множества пар чисел {(a, b)}.
Каждая такая пара означает, что данное регулярное выражение может 
принимать слова длины c, если уравнение a+bx=c имеет решение в
 целых числах по модулю k.

Когда нужно будет узнать принимает ли регулярное выражение 
значение l по модулю k просто решаем сравнение. (xb=l-a, если l-a делится на НОД(b, k)), то решение есть.)

Что делают операции:
### . (конкатенация)
Перебираем все пары (u, v), где u из пар первой регулярки, а v из пар второй
 и дописываем в результат пару (u.first+v.first, gcd(u.second, v.second)).

Если первый элемент получился больше второго, то делаем first%=second

### + (сумма)
Просто объединяем множества пар

### * (звезда клини)
берем gcd всех чисел во всех парах и возвращаем {(0, gcd)}

# Асимптотика
Нетрудно заметить, что вместо регулярки длины n хранится не более n^2 пар.
Первым числам в парах гарантированно должны соответствовать какие-то буквы, а вторые не могут быть больше максимального первого.
 
Реально их будет меньше, но я не знаю как это доказвать.

Чтобы упростить проверку на повторы будем просто использовать std:set

Тогда асимптотики операций:

+:O(n^2log(n))
*:O(n^2)
.:O(n^4log(n))

Итоговая асимптотика не превосходит O(n^5log(n))
Но я не смог придумать тест с такой асимптотико, и возможно асимптотика меньше.
В среднем думаю гораздо меньше
Ну и если честно, то будет еще + асимптотика вычисления gcd(x, k) при x <= n. Но это точно не медленнее O(nlog(k)), а в среднем гораздо быстрее.

Задачу решал в предположении, что k ооочень большое и никакими векторами булей не поработаешь, а асимптотика соотвественно должна минимально зависить от k.

# Запуск
Вроде должен собираться сам через команду cmake make, но я не тестил вне CLION (на винде)

И вроде должен делать 2 .exe файла из обычного main.cpp файла (с вводом и выводом) и test_main.cpp (запуск тестов)

Если не собирается, то печально, придется в CMakeLists.txt заменить "main.cpp" на "test_main.cpp"

Конец.
